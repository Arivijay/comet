name: gke-infra-and-app

on:
  # Manual only to avoid surprise re-provisioning; turn push back on when ready
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  TF_GKE_DIR: terraform/gke
  HELM_RELEASE: hello-world
  HELM_CHART_DIR: helm/hello-world
  CHART_PACKAGE_DIR: packaged
  CLUSTER_NAME: ${{ vars.CLUSTER_NAME || 'comet-hello-gke' }}
  GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  # IMPORTANT: must be a REGION (e.g., us-central1), not a zone
  GKE_LOCATION: ${{ vars.GKE_LOCATION || 'us-central1' }}
  GHCR_IMAGE: ${{ vars.GHCR_IMAGE || format('ghcr.io/{0}/k8s-hello-world-app', github.repository_owner) }}

jobs:
  build_and_push_app:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        run: |
          docker build -t "${GHCR_IMAGE}:${GITHUB_SHA}" ./app
          docker push "${GHCR_IMAGE}:${GITHUB_SHA}"

      - name: Expose image info
        id: meta
        run: |
          echo "image=${GHCR_IMAGE}" >> $GITHUB_OUTPUT
          echo "tag=${GITHUB_SHA}" >> $GITHUB_OUTPUT
    outputs:
      image: ${{ steps.meta.outputs.image }}
      tag: ${{ steps.meta.outputs.tag }}

  terraform_gke:
    # keep this separate so you can also run it alone if needed
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5

      - name: Terraform Init/Validate/Plan
        working-directory: ${{ env.TF_GKE_DIR }}
        env:
          GOOGLE_CREDENTIALS: ${{ secrets.GCP_SA_KEY }}
        run: |
          terraform init -input=false
          terraform fmt -recursive
          terraform validate
          terraform plan -out=tfplan -input=false \
            -var="project_id=${{ env.GCP_PROJECT_ID }}" \
            -var="region=${{ env.GKE_LOCATION }}"

      - name: Terraform Apply
        working-directory: ${{ env.TF_GKE_DIR }}
        env:
          GOOGLE_CREDENTIALS: ${{ secrets.GCP_SA_KEY }}
        run: terraform apply -auto-approve tfplan

  deploy_and_test:
    # No 'needs' so you can run this job by itself from Actions
    runs-on: ubuntu-latest
    container:
      image: gcr.io/google.com/cloudsdktool/google-cloud-cli:slim
    env:
      # Force kubectl/helm to use the kubeconfig we write below
      KUBECONFIG: ${{ github.workspace }}/kubeconfig
      HELM_KUBECONFIG: ${{ github.workspace }}/kubeconfig
      # If you run deploy alone, these may be empty; we'll default them in-shell
      IMAGE_REPO: ${{ needs.build_and_push_app.outputs.image }}
      IMAGE_TAG:  ${{ needs.build_and_push_app.outputs.tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set project in gcloud
        run: gcloud config set project "${{ env.GCP_PROJECT_ID }}"

      # Ensure kubectl exists inside the container (no sudo available)
      - name: Install kubectl (apt)
        run: |
          apt-get update
          apt-get install -y kubectl
          which kubectl && kubectl version --client=true

      # Nuke any default kubeconfigs that could contain exec stanzas
      - name: Remove any pre-existing kubeconfigs
        run: |
          rm -f /github/home/.kube/config || true
          rm -f ~/.kube/config || true

      # Build a clean kubeconfig that uses a short-lived bearer token (no exec plugin)
      - name: Build kubeconfig (no exec plugin)
        env:
          PROJECT_ID:   ${{ env.GCP_PROJECT_ID }}
          CLUSTER_NAME: ${{ env.CLUSTER_NAME }}
          GKE_LOCATION: ${{ env.GKE_LOCATION }}
        run: |
          set -euo pipefail
          ENDPOINT="$(gcloud container clusters describe "${CLUSTER_NAME}" \
            --region "${GKE_LOCATION}" --project "${PROJECT_ID}" \
            --format='value(endpoint)')"

          CA_B64="$(gcloud container clusters describe "${CLUSTER_NAME}" \
            --region "${GKE_LOCATION}" --project "${PROJECT_ID}" \
            --format='value(masterAuth.clusterCaCertificate)')"

          echo "$CA_B64" | base64 -d > ca.crt
          ACCESS_TOKEN="$(gcloud auth print-access-token)"

          cat > "$KUBECONFIG" <<EOF
          apiVersion: v1
          kind: Config
          clusters:
          - cluster:
              certificate-authority-data: ${CA_B64}
              server: https://${ENDPOINT}
            name: gke-ci
          contexts:
          - context:
              cluster: gke-ci
              user: gke-ci-user
            name: gke-ci
          current-context: gke-ci
          users:
          - name: gke-ci-user
            user:
              token: ${ACCESS_TOKEN}
          EOF

          echo "Wrote kubeconfig to $KUBECONFIG"
          echo "Checking for any 'exec:' stanzas (should be none):"
          ! grep -n 'exec:' "$KUBECONFIG" || (echo "ERROR: found exec in kubeconfig" && exit 1)

      - name: Sanity check cluster
        run: |
          kubectl --kubeconfig "$KUBECONFIG" cluster-info
          kubectl --kubeconfig "$KUBECONFIG" get nodes

      - name: Install Helm
        run: |
          curl -L https://get.helm.sh/helm-v3.14.4-linux-amd64.tar.gz -o helm.tgz
          tar -xzf helm.tgz
          mv linux-amd64/helm /usr/local/bin/helm
          helm version

      - name: Add Bitnami repo & pull dependencies
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm dependency update "${{ env.HELM_CHART_DIR }}"

      - name: Lint chart
        run: helm lint "${{ env.HELM_CHART_DIR }}"

      - name: Deploy (upgrade --install)
        env:
          GHCR_IMAGE: ${{ env.GHCR_IMAGE }}
        run: |
          # If deploy runs alone, default to GHCR_IMAGE + GITHUB_SHA
          repo="${IMAGE_REPO:-${GHCR_IMAGE}}"
          tag="${IMAGE_TAG:-${GITHUB_SHA}}"

          echo "Deploying image ${repo}:${tag}"
          helm upgrade --install "${{ env.HELM_RELEASE }}" "${{ env.HELM_CHART_DIR }}" --wait \
            --kubeconfig "$KUBECONFIG" \
            --set image.repository="${repo}" \
            --set image.tag="${tag}"

          kubectl --kubeconfig "$KUBECONFIG" get svc -o wide

      - name: Run helm test
        run: helm --kubeconfig "$KUBECONFIG" test "${{ env.HELM_RELEASE }}" --logs

      - name: Package chart
        run: |
          mkdir -p "${{ env.CHART_PACKAGE_DIR }}"
          helm package "${{ env.HELM_CHART_DIR }}" --destination "${{ env.CHART_PACKAGE_DIR }}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: chart-package
          path: ${{ env.CHART_PACKAGE_DIR }}/*.tgz
