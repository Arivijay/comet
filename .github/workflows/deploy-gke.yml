name: gke-infra-and-app

on:
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  TF_GKE_DIR: terraform/gke
  HELM_RELEASE: hello-world
  HELM_CHART_DIR: helm/hello-world
  CHART_PACKAGE_DIR: packaged
  CLUSTER_NAME: ${{ vars.CLUSTER_NAME || 'comet-hello-gke' }}
  GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  # Must be a REGION, e.g., us-central1
  GKE_LOCATION: ${{ vars.GKE_LOCATION || 'us-central1' }}
  GHCR_IMAGE: ${{ vars.GHCR_IMAGE || format('ghcr.io/{0}/k8s-hello-world-app', github.repository_owner) }}

jobs:
  build_and_push_app:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push
        run: |
          docker build -t "${GHCR_IMAGE}:${GITHUB_SHA}" ./app
          docker push "${GHCR_IMAGE}:${GITHUB_SHA}"
      - name: Expose image info
        id: meta
        run: |
          echo "image=${GHCR_IMAGE}" >> $GITHUB_OUTPUT
          echo "tag=${GITHUB_SHA}" >> $GITHUB_OUTPUT
    outputs:
      image: ${{ steps.meta.outputs.image }}
      tag: ${{ steps.meta.outputs.tag }}

  terraform_gke:
    needs: build_and_push_app
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5
      - name: Terraform Init/Validate/Plan
        working-directory: ${{ env.TF_GKE_DIR }}
        env:
          GOOGLE_CREDENTIALS: ${{ secrets.GCP_SA_KEY }}
        run: |
          terraform init -input=false
          terraform fmt -recursive
          terraform validate
          terraform plan -out=tfplan -input=false \
            -var="project_id=${{ env.GCP_PROJECT_ID }}" \
            -var="region=${{ env.GKE_LOCATION }}"
      - name: Terraform Apply
        working-directory: ${{ env.TF_GKE_DIR }}
        env:
          GOOGLE_CREDENTIALS: ${{ secrets.GCP_SA_KEY }}
        run: terraform apply -auto-approve tfplan

  deploy_and_test:
    needs: [build_and_push_app, terraform_gke]
    runs-on: ubuntu-latest
    container:
      image: gcr.io/google.com/cloudsdktool/google-cloud-cli:slim
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set project in gcloud
        run: gcloud config set project "${{ env.GCP_PROJECT_ID }}"

      - name: Install kubectl (apt)
        run: |
          apt-get update
          apt-get install -y kubectl
          which kubectl && kubectl version --client=true

      # === Build a CLEAN kubeconfig and force everyone to use it ===
      - name: Build kubeconfig (no exec plugin)
        env:
          PROJECT_ID:   ${{ env.GCP_PROJECT_ID }}
          CLUSTER_NAME: ${{ env.CLUSTER_NAME }}
          GKE_LOCATION: ${{ env.GKE_LOCATION }}
        run: |
          set -euo pipefail

          # 1) Cluster endpoint & CA (no kubeconfig is created here)
          ENDPOINT="$(gcloud container clusters describe "${CLUSTER_NAME}" \
            --region "${GKE_LOCATION}" --project "${PROJECT_ID}" \
            --format='value(endpoint)')"

          CA_B64="$(gcloud container clusters describe "${CLUSTER_NAME}" \
            --region "${GKE_LOCATION}" --project "${PROJECT_ID}" \
            --format='value(masterAuth.clusterCaCertificate)')"

          echo "$CA_B64" | base64 -d > ca.crt

          # 2) Get OAuth token for this job
          ACCESS_TOKEN="$(gcloud auth print-access-token)"

          # 3) Write minimal kubeconfig to ./kubeconfig (no exec blocks)
          cat > kubeconfig <<EOF
          apiVersion: v1
          kind: Config
          clusters:
          - cluster:
              certificate-authority-data: ${CA_B64}
              server: https://${ENDPOINT}
            name: gke-ci
          contexts:
          - context:
              cluster: gke-ci
              user: gke-ci-user
            name: gke-ci
          current-context: gke-ci
          users:
          - name: gke-ci-user
            user:
              token: ${ACCESS_TOKEN}
          EOF

          # 4) Make kubectl/helm use THIS file
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

          # Safety check: ensure no 'exec:' stanza exists
          grep -n 'exec:' kubeconfig && exit 1 || true

      - name: Sanity check cluster
        run: |
          kubectl --kubeconfig "$KUBECONFIG" cluster-info
          kubectl --kubeconfig "$KUBECONFIG" get nodes

      - name: Install Helm
        run: |
          curl -L https://get.helm.sh/helm-v3.14.4-linux-amd64.tar.gz -o helm.tgz
          tar -xzf helm.tgz
          mv linux-amd64/helm /usr/local/bin/helm
          helm version

      - name: Add Bitnami repo & pull dependencies
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm dependency update "${{ env.HELM_CHART_DIR }}"

      - name: Lint chart
        run: helm lint "${{ env.HELM_CHART_DIR }}"

      - name: Deploy (upgrade --install)
        run: |
          helm upgrade --install "${{ env.HELM_RELEASE }}" "${{ env.HELM_CHART_DIR }}" --wait \
            --kubeconfig "$KUBECONFIG" \
            --set image.repository="${{ needs.build_and_push_app.outputs.image }}" \
            --set image.tag="${{ needs.build_and_push_app.outputs.tag }}"
          kubectl --kubeconfig "$KUBECONFIG" get svc -o wide

      - name: Run helm test
        run: helm --kubeconfig "$KUBECONFIG" test "${{ env.HELM_RELEASE }}" --logs

      - name: Package chart
        run: |
          mkdir -p "${{ env.CHART_PACKAGE_DIR }}"
          helm package "${{ env.HELM_CHART_DIR }}" --destination "${{ env.CHART_PACKAGE_DIR }}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: chart-package
          path: ${{ env.CHART_PACKAGE_DIR }}/*.tgz
