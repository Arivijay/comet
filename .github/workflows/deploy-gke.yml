name: gke-infra-and-app

on:
  # Manual only to avoid surprise re-provisioning. Turn push back on when ready.
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  TF_GKE_DIR: terraform/gke
  HELM_RELEASE: hello-world
  HELM_CHART_DIR: helm/hello-world
  CHART_PACKAGE_DIR: packaged
  CLUSTER_NAME: ${{ vars.CLUSTER_NAME || 'comet-hello-gke' }}
  GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  # IMPORTANT: Must be a REGION (e.g., us-central1), not a zone
  GKE_LOCATION: ${{ vars.GKE_LOCATION || 'us-central1' }}
  GHCR_IMAGE: ${{ vars.GHCR_IMAGE || format('ghcr.io/{0}/k8s-hello-world-app', github.repository_owner) }}

jobs:
  build_and_push_app:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        run: |
          docker build -t "${GHCR_IMAGE}:${GITHUB_SHA}" ./app
          docker push "${GHCR_IMAGE}:${GITHUB_SHA}"

      - name: Expose image info
        id: meta
        run: |
          echo "image=${GHCR_IMAGE}" >> $GITHUB_OUTPUT
          echo "tag=${GITHUB_SHA}" >> $GITHUB_OUTPUT
    outputs:
      image: ${{ steps.meta.outputs.image }}
      tag: ${{ steps.meta.outputs.tag }}

  terraform_gke:
    needs: build_and_push_app
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5

      - name: Terraform Init/Validate/Plan
        working-directory: ${{ env.TF_GKE_DIR }}
        env:
          GOOGLE_CREDENTIALS: ${{ secrets.GCP_SA_KEY }}
        run: |
          terraform init -input=false
          terraform fmt -recursive
          terraform validate
          terraform plan -out=tfplan -input=false \
            -var="project_id=${{ env.GCP_PROJECT_ID }}" \
            -var="region=${{ env.GKE_LOCATION }}"

      - name: Terraform Apply
        working-directory: ${{ env.TF_GKE_DIR }}
        env:
          GOOGLE_CREDENTIALS: ${{ secrets.GCP_SA_KEY }}
        run: terraform apply -auto-approve tfplan

  deploy_and_test:
    needs: [build_and_push_app, terraform_gke]
    runs-on: ubuntu-latest
    # Run inside Cloud SDK container (has gcloud; weâ€™ll apt-install kubectl)
    container:
      image: gcr.io/google.com/cloudsdktool/google-cloud-cli:slim
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set project in gcloud
        run: gcloud config set project "${{ env.GCP_PROJECT_ID }}"

      # Ensure kubectl is present in the container (no sudo in this image)
      - name: Install kubectl (apt)
        run: |
          apt-get update
          apt-get install -y kubectl
          which kubectl && kubectl version --client=true

      # Build kubeconfig WITHOUT the GKE auth plugin (use bearer token)
      - name: Build kubeconfig without auth plugin
        env:
          PROJECT_ID:   ${{ env.GCP_PROJECT_ID }}
          CLUSTER_NAME: ${{ env.CLUSTER_NAME }}
          GKE_LOCATION: ${{ env.GKE_LOCATION }}
        run: |
          set -euo pipefail

          # 1) Get API endpoint + CA certificate
          ENDPOINT="$(gcloud container clusters describe "${CLUSTER_NAME}" \
            --region "${GKE_LOCATION}" --project "${PROJECT_ID}" \
            --format='value(endpoint)')"

          CA_B64="$(gcloud container clusters describe "${CLUSTER_NAME}" \
            --region "${GKE_LOCATION}" --project "${PROJECT_ID}" \
            --format='value(masterAuth.clusterCaCertificate)')"

          echo "$CA_B64" | base64 -d > ca.crt

          # 2) Get an OAuth access token tied to this job
          ACCESS_TOKEN="$(gcloud auth print-access-token)"

          # 3) Write kubeconfig
          kubectl config set-cluster gke-ci \
            --server="https://${ENDPOINT}" \
            --certificate-authority=ca.crt

          kubectl config set-credentials gke-ci-user \
            --token="${ACCESS_TOKEN}"

          kubectl config set-context gke-ci \
            --cluster=gke-ci \
            --user=gke-ci-user

          kubectl config use-context gke-ci

      - name: Sanity check cluster
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Install Helm
        run: |
          curl -L https://get.helm.sh/helm-v3.14.4-linux-amd64.tar.gz -o helm.tgz
          tar -xzf helm.tgz
          mv linux-amd64/helm /usr/local/bin/helm
          helm version

      - name: Add Bitnami repo & pull dependencies
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm dependency update "${{ env.HELM_CHART_DIR }}"

      - name: Lint chart
        run: helm lint "${{ env.HELM_CHART_DIR }}"

      - name: Deploy (upgrade --install)
        run: |
          helm upgrade --install "${{ env.HELM_RELEASE }}" "${{ env.HELM_CHART_DIR }}" --wait \
            --set image.repository="${{ needs.build_and_push_app.outputs.image }}" \
            --set image.tag="${{ needs.build_and_push_app.outputs.tag }}"
          kubectl get svc -o wide

      - name: Run helm test
        run: helm test "${{ env.HELM_RELEASE }}" --logs

      - name: Package chart
        run: |
          mkdir -p "${{ env.CHART_PACKAGE_DIR }}"
          helm package "${{ env.HELM_CHART_DIR }}" --destination "${{ env.CHART_PACKAGE_DIR }}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: chart-package
          path: ${{ env.CHART_PACKAGE_DIR }}/*.tgz
